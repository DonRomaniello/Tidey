[{"/Users/donromaniello/Code/JavaScript/tidey/src/index.js":"1","/Users/donromaniello/Code/JavaScript/tidey/src/reportWebVitals.js":"2","/Users/donromaniello/Code/JavaScript/tidey/src/App.js":"3","/Users/donromaniello/Code/JavaScript/tidey/src/components/Station.js":"4","/Users/donromaniello/Code/JavaScript/tidey/src/components/Map.js":"5","/Users/donromaniello/Code/JavaScript/tidey/src/store/store.js":"6","/Users/donromaniello/Code/JavaScript/tidey/src/store/features/stations.js":"7","/Users/donromaniello/Code/JavaScript/tidey/src/components/customReactLeaflet.js":"8","/Users/donromaniello/Code/JavaScript/tidey/src/components/Epicycles.js":"9","/Users/donromaniello/Code/JavaScript/tidey/src/store/features/harmonics.js":"10","/Users/donromaniello/Code/JavaScript/tidey/src/components/modules/drawHarmonicConstituents.js":"11","/Users/donromaniello/Code/JavaScript/tidey/src/components/css/Epicycles.module.js":"12","/Users/donromaniello/Code/JavaScript/tidey/src/components/CompassRose.js":"13","/Users/donromaniello/Code/JavaScript/tidey/src/store/features/compass.js":"14"},{"size":613,"mtime":1662512679018,"results":"15","hashOfConfig":"16"},{"size":362,"mtime":1662512679021,"results":"17","hashOfConfig":"16"},{"size":737,"mtime":1662512678969,"results":"18","hashOfConfig":"16"},{"size":804,"mtime":1659655443010,"results":"19","hashOfConfig":"16"},{"size":1652,"mtime":1662512678971,"results":"20","hashOfConfig":"16"},{"size":366,"mtime":1662512679023,"results":"21","hashOfConfig":"16"},{"size":1031,"mtime":1662512679023,"results":"22","hashOfConfig":"16"},{"size":734,"mtime":1659880760019,"results":"23","hashOfConfig":"16"},{"size":2481,"mtime":1662512678971,"results":"24","hashOfConfig":"16"},{"size":1099,"mtime":1662512679023,"results":"25","hashOfConfig":"16"},{"size":5253,"mtime":1662512678979,"results":"26","hashOfConfig":"16"},{"size":339,"mtime":1662394486416,"results":"27","hashOfConfig":"16"},{"size":1518,"mtime":1662512678970,"results":"28","hashOfConfig":"16"},{"size":911,"mtime":1662512679022,"results":"29","hashOfConfig":"16"},{"filePath":"30","messages":"31","suppressedMessages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"1c80qc6",{"filePath":"33","messages":"34","suppressedMessages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"36","messages":"37","suppressedMessages":"38","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"39","messages":"40","suppressedMessages":"41","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"43","messages":"44","suppressedMessages":"45","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"46","messages":"47","suppressedMessages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"49","messages":"50","suppressedMessages":"51","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"42"},{"filePath":"55","messages":"56","suppressedMessages":"57","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"58"},{"filePath":"59","messages":"60","suppressedMessages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"62","messages":"63","suppressedMessages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"65"},{"filePath":"66","messages":"67","suppressedMessages":"68","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"69","messages":"70","suppressedMessages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"72","messages":"73","suppressedMessages":"74","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/donromaniello/Code/JavaScript/tidey/src/index.js",[],[],"/Users/donromaniello/Code/JavaScript/tidey/src/reportWebVitals.js",[],[],"/Users/donromaniello/Code/JavaScript/tidey/src/App.js",[],[],"/Users/donromaniello/Code/JavaScript/tidey/src/components/Station.js",[],[],[],"/Users/donromaniello/Code/JavaScript/tidey/src/components/Map.js",[],[],"/Users/donromaniello/Code/JavaScript/tidey/src/store/store.js",[],[],"/Users/donromaniello/Code/JavaScript/tidey/src/store/features/stations.js",[],[],"/Users/donromaniello/Code/JavaScript/tidey/src/components/customReactLeaflet.js",[],[],"/Users/donromaniello/Code/JavaScript/tidey/src/components/Epicycles.js",["75"],[],"\nimport React, {useState, useEffect} from 'react';\n\nimport { useDispatch, useSelector } from 'react-redux';\n\nimport { fetchHarmonics } from '../store/features/harmonics';\n\nimport L from 'leaflet';\n\nimport {\n  Marker,\n  Popup,\n} from 'react-leaflet'\n\n\nimport drawVisualizer from './modules/drawHarmonicConstituents';\n\nimport icon from './assets/pin.svg';\n\n// import iconShadow from 'leaflet/dist/images/marker-shadow.png';\n\n// import styles from './css/Epicycles.module.css'\n\nconst Epicycles = (props) => {\n\n  const { stationInfo } = props\n\n  const harmonics = useSelector((state) => state.harmonics)\n\n  const [couldOpen, setCouldOpen] = useState(false)\n\n  const dispatch = useDispatch();\n\n  const DefaultIcon = L.icon({\n    iconUrl: icon,\n    // shadowUrl: iconShadow,\n    iconAnchor: [16, 42],\n    popupAnchor: [-50, 0],// this should be half width, full height of popup\n  });\n\n  L.Popup.prototype.options.offset = [0,0] // look here\n\n  L.Marker.prototype.options.icon = DefaultIcon;\n\n  L.Popup.prototype.options.maxWidth = '1000%'\n\n  L.Popup.prototype.options.className = 'popuply'\n\n  const position = [stationInfo?.lat, stationInfo?.lng]\n\n  const canvasName = `epicycleCanvas + ${stationInfo.id + stationInfo.lat + stationInfo.lng}`\n\n  const autoPanPad = {\n    x: (window.innerWidth - 500) / 2,\n    y: (window.innerHeight - 300) / 2,\n }\n\n  const stopLooping = () => {\n    return {\n      continue: couldOpen,\n      numOfConstituents: 5,\n  }\n}\n\n  useEffect(() => {\n    if (harmonics.loaded && couldOpen) {\n      drawVisualizer(harmonics.harmonics, canvasName, constituentColors,\n        [400, 200], stopLooping)\n    }\n  }, [canvasName, couldOpen, harmonics])\n\n  return (\n    <>\n    <Marker\n    maxWidth='400px'\n    position={position}\n    autoPan={true}\n    autoPanOnFocus={true}\n    riseOnHover={true}\n    eventHandlers={{\n      popupopen: () => {\n        dispatch(fetchHarmonics(stationInfo.harmonicConstituents))\n        setCouldOpen(true);\n      },\n      popupclose: () => {\n        setCouldOpen(false)\n      }\n    }}\n    >\n      <Popup\n      autoPanPadding={autoPanPad}\n      autoPan={true}\n      >\n        {((harmonics.loaded) && couldOpen) ?\n          <canvas id={canvasName}/>\n            :\n          <div className='loading' >\n            loading...\n            </div>}\n      </Popup>\n    </Marker>\n    </>\n)\n}\n\nconst constituentColors = {\n  start : {\n    r: 22,\n    g: 105,\n    b: 122\n  },\n  end : {\n    r: 134,\n    g: 216,\n    b: 154\n  }\n}\n\n\n\nexport default Epicycles\n\n","/Users/donromaniello/Code/JavaScript/tidey/src/store/features/harmonics.js",[],[],"/Users/donromaniello/Code/JavaScript/tidey/src/components/modules/drawHarmonicConstituents.js",["76","77"],[],"\nconst drawVisualizer = (harcon,\n  canvasName,\n  colorRange,\n    canvasSize = [500, 500],\n    loopCallback) => {\n// Record the initial time so the delta can be calculated later\nconst timeSubtract = new Date().getTime()\n// The amplitude indicators on the harmonics are called beads\nlet callbackMessages = loopCallback()\nconst beadSize = 2\nconst mainSpeed = 1\nconst frameRate = 60\nconst axesStrokeColor = 'rgba(128, 128, 128, 1)'\nconst beadColor = 'rgba(255, 0, 0, 1)'\nconst wavePrecision = 20 // How smooth the tide chart curves should be\nlet constituents = [...harcon]\nconstituents.sort((a, b) => b.amplitude - a.amplitude)\nconstituents = constituents.slice(0, callbackMessages.numOfConstituents)\nlet width = canvasSize[0]\nlet height = canvasSize[1]\n// This is how much to scale by\nconst scale = constituents.map((a) => a.amplitude).reduce((a, b) => a + b)\n\nconst unit = ((height / 2) / scale)\n\nlet timeSeriesChords = []\n\nlet timeSeriesCounter = 0\n\n// declare a lot of variables that should not be redeclared each time\nlet canvas, ctx, featureFillColor, featureStrokeColor, xAxis, yAxis,\n   nextXCenter, nextYCenter, timeSeriesLength;\n\nconst emptyFunction = () => {\n}\n\nconst init = () => {\n  // this may change, will revisit\n  canvas = document.getElementById(canvasName);\n\n  canvas.width = canvasSize[0];\n  canvas.height = canvasSize[1];\n\n  ctx = canvas.getContext(\"2d\");\n  ctx.lineJoin = 'round';\n\n  xAxis = Math.floor(height/2);\n  yAxis = Math.floor(width/4 - scale);\n\n  timeSeriesLength = ((width - yAxis))\n\n  populateTimeSeries(timeSeriesLength, emptyFunction)\n\n  ctx.save();\n\n  window.requestAnimationFrame(draw);\n}\n\nconst draw = () => {\n\n  const time = new Date()\n\n  nextXCenter = yAxis\n  nextYCenter = xAxis\n\n  ctx.clearRect(0, 0, width, height);\n\n  // Draw the axes in their own path\n  ctx.strokeStyle = axesStrokeColor;\n  ctx.beginPath();\n  drawAxes();\n\n  // Set styles for animated graphics\n  ctx.save();\n  ctx.strokeStyle = featureStrokeColor;\n  ctx.fillStyle = featureFillColor;\n  ctx.lineWidth = 1;\n\n  // Update the time and draw again\n  draw.t = (time - timeSubtract) / (100000 / mainSpeed);\n  runThroughConstituents(draw.t * Math.PI, drawEpicycles)\n  drawTideChart();\n  drawArrow();\n  drawBead()\n  ctx.restore();\n\n  callbackMessages = loopCallback()\n\n  if (callbackMessages.continue){\n    setTimeout(draw, (1000 / frameRate));\n  }\n\n}\n\nconst runThroughConstituents = (time, drawFunction) => {\n  constituents.forEach((constituent, idx) => {\n    const radius = Math.floor(constituent.amplitude * unit)\n    drawFunction(radius, idx)\n    getLocationOnCircle(time, radius, constituent)\n    timeSeriesCounter++;\n    if (idx == (constituents.length - 1) && (timeSeriesCounter % wavePrecision == 0)) {\n      timeSeriesChords = [...timeSeriesChords, nextYCenter].slice(-timeSeriesLength)\n    }\n  })\n}\n\nconst getRadians = (angle) => {\n  return (angle * (Math.PI / 180))\n}\n\nconst getSteppedColor = (idx) => {\n  let degreeB = idx / callbackMessages.numOfConstituents\n  let degreeA = 1 - degreeB\n  let r = (colorRange.start.r * degreeA) + (colorRange.end.r * degreeB)\n  let g = (colorRange.start.g * degreeA) + (colorRange.end.g * degreeB)\n  let b = (colorRange.start.b * degreeA) + (colorRange.end.b * degreeB)\n  return { r, g, b}\n}\n\n\nconst getLocationOnCircle = (time, radius, constituent) => {\n  let nextCenters = getPhasedXY(time, radius, constituent)\n  nextXCenter = nextCenters[0]\n  nextYCenter = nextCenters[1]\n}\n\nconst getPhasedXY = (time, radius, constituent) => {\n  const { phase_GMT, speed} = constituent\n  let phase = phase_GMT\n  let phaseX = nextXCenter + (radius * Math.sin(((time + getRadians(phase)) * speed)))\n  let phaseY = nextYCenter + (radius * Math.cos(((time + getRadians(phase)) * speed)))\n  return [phaseX, phaseY]\n}\n\nconst populateTimeSeries = (timeSeriesLength) => {\n  for (let i = 0; i < timeSeriesLength; i++) {\n    runThroughConstituents(i, emptyFunction)\n    timeSeriesChords.push(nextYCenter)\n  }\n}\n\n// Drawing functions\nconst drawArrow = () => {\n  ctx.beginPath()\n  ctx.setLineDash([5, 10]);\n  ctx.moveTo(yAxis, nextYCenter)\n  ctx.lineTo(nextXCenter, nextYCenter)\n  ctx.stroke()\n}\n\nconst drawBead = () => {\n  ctx.beginPath()\n      ctx.strokeStyle = beadColor;\n      ctx.fillStyle = beadColor;\n      ctx.arc(nextXCenter, nextYCenter, beadSize, 0, 2 * Math.PI, false);\n      ctx.fill();\n      ctx.stroke();\n      ctx.strokeStyle = featureStrokeColor; // restore color\n}\n\n\nconst drawEpicycles = (radius, idx) => {\n  let baseColor = getSteppedColor(idx)\n  ctx.strokeStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 1)`\n  ctx.fillStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, .2)`\n  ctx.beginPath()\n  ctx.arc(nextXCenter, nextYCenter, radius, 0, 2 * Math.PI, false);\n  // ctx.fill();\n  ctx.stroke();\n}\n\nfunction drawTideChart() {\n  ctx.beginPath();\n  ctx.moveTo(width, timeSeriesChords[0]);\n  timeSeriesChords.slice(1).forEach((yCoordinate, idx) => {\n      ctx.lineTo((width - ((idx + 1))), yCoordinate);\n  })\n  ctx.stroke();\n}\n\n\nconst drawAxes = () => {\n  // Draw X and Y axes\n  ctx.strokeStyle = axesStrokeColor;\n  // ctx.moveTo(0, xAxis);\n  // ctx.lineTo(width, xAxis);\n  // ctx.moveTo(yAxis, 0);\n  // ctx.lineTo(yAxis, height);\n  ctx.stroke();\n}\n\ninit()\n\n}\n\n\n\nexport default drawVisualizer\n","/Users/donromaniello/Code/JavaScript/tidey/src/components/css/Epicycles.module.js",[],[],"/Users/donromaniello/Code/JavaScript/tidey/src/components/CompassRose.js",[],[],"/Users/donromaniello/Code/JavaScript/tidey/src/store/features/compass.js",[],[],{"ruleId":"78","severity":1,"message":"79","line":70,"column":6,"nodeType":"80","endLine":70,"endColumn":40,"suggestions":"81"},{"ruleId":"82","severity":1,"message":"83","line":102,"column":13,"nodeType":"84","messageId":"85","endLine":102,"endColumn":15},{"ruleId":"82","severity":1,"message":"83","line":102,"column":80,"nodeType":"84","messageId":"85","endLine":102,"endColumn":82},"react-hooks/exhaustive-deps","React Hook useEffect has a missing dependency: 'stopLooping'. Either include it or remove the dependency array.","ArrayExpression",["86"],"eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected",{"desc":"87","fix":"88"},"Update the dependencies array to be: [canvasName, couldOpen, harmonics, stopLooping]",{"range":"89","text":"90"},[1624,1658],"[canvasName, couldOpen, harmonics, stopLooping]"]