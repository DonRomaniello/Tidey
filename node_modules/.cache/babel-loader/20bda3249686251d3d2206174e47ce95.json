{"ast":null,"code":"const drawVisualizer = function (harcon, canvasName) {\n  let numOfConstituents = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5;\n  let canvasSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [500, 500];\n  // Record the initial time so the delta can be calculated later\n  const timeSubtract = new Date().getTime(); // The amplitude indicators on the harmonics are called beads\n\n  const beadSize = 2;\n  const speed = 1;\n  const frameRate = 60;\n  const axesStrokeColor = 'rgba(128, 128, 128, 1)';\n  const featureFillColor = 'rgba(0, 128, 255, .1)';\n  const featureStrokeColor = 'rgba(0, 128, 255, 1)';\n  let beadColor = 'rgba(255, 0, 0, 1)';\n  const wavePrecision = .25; // How smooth the tide chart curves should be\n\n  let constituents = [...harcon];\n  constituents.sort((a, b) => b.amplitude - a.amplitude);\n  constituents = constituents.slice(0, numOfConstituents);\n  let width = canvasSize[0];\n  let height = canvasSize[1]; // This is how much to scale by\n\n  const scale = constituents.map(a => a.amplitude).reduce((a, b) => a + b);\n  const unit = height / 2 / scale;\n  let timeSeriesChords = []; // declare a lot of variables that should not be redeclared each time\n\n  let canvas, ctx, xAxis, yAxis, x, y, nextXCenter, nextYCenter, timeSeriesLength;\n\n  const emptyFunction = () => {};\n\n  const init = () => {\n    // this may change, will revisit\n    canvas = document.getElementById(canvasName);\n    canvas.width = canvasSize[0];\n    canvas.height = canvasSize[1];\n    ctx = canvas.getContext(\"2d\");\n    ctx.lineJoin = 'round';\n    xAxis = Math.floor(height / 2);\n    yAxis = Math.floor(scale);\n    timeSeriesLength = (width - yAxis) / wavePrecision;\n    populateTimeSeries(timeSeriesLength, emptyFunction);\n    ctx.save();\n    window.requestAnimationFrame(draw);\n  };\n\n  const draw = () => {\n    const time = new Date();\n    nextXCenter = yAxis;\n    nextYCenter = xAxis;\n    ctx.clearRect(0, 0, width, height); // Draw the axes in their own path\n\n    ctx.strokeStyle = axesStrokeColor;\n    ctx.beginPath();\n    drawAxes(); // Set styles for animated graphics\n\n    ctx.save();\n    ctx.strokeStyle = featureStrokeColor;\n    ctx.fillStyle = featureFillColor;\n    ctx.lineWidth = 1; // Update the time and draw again\n\n    draw.t = (time - timeSubtract) / (100000 / speed);\n    runThroughConstituents(draw.t * Math.PI, drawEpicycles);\n    drawTideChart();\n    drawArrow();\n    drawBead();\n    ctx.restore();\n    setTimeout(draw, 1000 / frameRate);\n  };\n\n  const runThroughConstituents = (time, drawFunction) => {\n    constituents.forEach((constituent, idx) => {\n      const radius = Math.floor(constituent.amplitude * unit);\n      drawFunction(radius);\n      getLocationOnCircle(time, radius, constituent);\n\n      if (idx == constituents.length - 1) {\n        timeSeriesChords = [...timeSeriesChords, nextYCenter].slice(-timeSeriesLength);\n      }\n    });\n  };\n\n  const getRadians = angle => {\n    return angle * (Math.PI / 180);\n  };\n\n  const getLocationOnCircle = (time, radius, constituent) => {\n    let nextCenters = getPhasedXY(time, radius, constituent);\n    nextXCenter = nextCenters[0];\n    nextYCenter = nextCenters[1];\n  };\n\n  const getPhasedXY = (time, radius, constituent) => {\n    const {\n      phase_GMT,\n      speed\n    } = constituent;\n    let phase = phase_GMT;\n    let phaseX = nextXCenter + radius * Math.sin((time + getRadians(phase)) * speed);\n    let phaseY = nextYCenter + radius * Math.cos((time + getRadians(phase)) * speed);\n    return [phaseX, phaseY];\n  };\n\n  const populateTimeSeries = timeSeriesLength => {\n    for (let i = 0; i < timeSeriesLength; i++) {\n      runThroughConstituents(i, emptyFunction);\n      timeSeriesChords.push(nextYCenter);\n    }\n  }; // Drawing functions\n\n\n  const drawArrow = () => {\n    ctx.beginPath();\n    ctx.setLineDash([5, 10]);\n    ctx.moveTo(yAxis, nextYCenter);\n    ctx.lineTo(nextXCenter, nextYCenter);\n    ctx.stroke();\n  };\n\n  const drawBead = () => {\n    ctx.beginPath();\n    ctx.strokeStyle = beadColor;\n    ctx.fillStyle = beadColor;\n    ctx.arc(nextXCenter, nextYCenter, beadSize, 0, 2 * Math.PI, false);\n    ctx.fill();\n    ctx.stroke();\n    ctx.strokeStyle = featureStrokeColor; // restore color\n  };\n\n  const drawEpicycles = radius => {\n    ctx.beginPath();\n    ctx.arc(nextXCenter, nextYCenter, radius, 0, 2 * Math.PI, false);\n    ctx.fill();\n    ctx.stroke();\n  };\n\n  function drawTideChart() {\n    ctx.beginPath();\n    ctx.moveTo(width, timeSeriesChords[0]);\n    timeSeriesChords.slice(1).forEach((yCoordinate, idx) => {\n      ctx.lineTo(width - (idx + 1) * wavePrecision, yCoordinate);\n    });\n    ctx.stroke();\n  }\n\n  const drawAxes = () => {\n    // Draw X and Y axes\n    ctx.strokeStyle = axesStrokeColor;\n    ctx.moveTo(0, xAxis);\n    ctx.lineTo(width, xAxis);\n    ctx.moveTo(yAxis, 0);\n    ctx.lineTo(yAxis, height);\n    ctx.stroke();\n  };\n\n  init();\n};\n\nexport default drawVisualizer;","map":{"version":3,"names":["drawVisualizer","harcon","canvasName","numOfConstituents","canvasSize","timeSubtract","Date","getTime","beadSize","speed","frameRate","axesStrokeColor","featureFillColor","featureStrokeColor","beadColor","wavePrecision","constituents","sort","a","b","amplitude","slice","width","height","scale","map","reduce","unit","timeSeriesChords","canvas","ctx","xAxis","yAxis","x","y","nextXCenter","nextYCenter","timeSeriesLength","emptyFunction","init","document","getElementById","getContext","lineJoin","Math","floor","populateTimeSeries","save","window","requestAnimationFrame","draw","time","clearRect","strokeStyle","beginPath","drawAxes","fillStyle","lineWidth","t","runThroughConstituents","PI","drawEpicycles","drawTideChart","drawArrow","drawBead","restore","setTimeout","drawFunction","forEach","constituent","idx","radius","getLocationOnCircle","length","getRadians","angle","nextCenters","getPhasedXY","phase_GMT","phase","phaseX","sin","phaseY","cos","i","push","setLineDash","moveTo","lineTo","stroke","arc","fill","yCoordinate"],"sources":["/Users/donromaniello/Code/JavaScript/tidey/src/components/modules/drawHarmonicConstituents.js"],"sourcesContent":["\nconst drawVisualizer = (harcon, canvasName,\n   numOfConstituents = 5,\n    canvasSize = [500, 500]) => {\n// Record the initial time so the delta can be calculated later\nconst timeSubtract = new Date().getTime()\n// The amplitude indicators on the harmonics are called beads\nconst beadSize = 2\nconst speed = 1\nconst frameRate = 60\nconst axesStrokeColor = 'rgba(128, 128, 128, 1)'\nconst featureFillColor = 'rgba(0, 128, 255, .1)'\nconst featureStrokeColor = 'rgba(0, 128, 255, 1)'\nlet beadColor = 'rgba(255, 0, 0, 1)'\nconst wavePrecision = .25 // How smooth the tide chart curves should be\nlet constituents = [...harcon]\nconstituents.sort((a, b) => b.amplitude - a.amplitude)\nconstituents = constituents.slice(0, numOfConstituents)\nlet width = canvasSize[0]\nlet height = canvasSize[1]\n\n// This is how much to scale by\nconst scale = constituents.map((a) => a.amplitude).reduce((a, b) => a + b)\n\nconst unit = ((height / 2) / scale)\n\nlet timeSeriesChords = []\n\n// declare a lot of variables that should not be redeclared each time\nlet canvas, ctx, xAxis, yAxis,\n    x, y, nextXCenter, nextYCenter, timeSeriesLength;\n\nconst emptyFunction = () => {\n}\n\nconst init = () => {\n  // this may change, will revisit\n  canvas = document.getElementById(canvasName);\n\n  canvas.width = canvasSize[0];\n  canvas.height = canvasSize[1];\n\n  ctx = canvas.getContext(\"2d\");\n  ctx.lineJoin = 'round';\n\n  xAxis = Math.floor(height/2);\n  yAxis = Math.floor(scale);\n\n  timeSeriesLength = ((width - yAxis) / wavePrecision)\n\n  populateTimeSeries(timeSeriesLength, emptyFunction)\n\n  ctx.save();\n\n  window.requestAnimationFrame(draw);\n}\n\nconst draw = () => {\n\n  const time = new Date()\n\n  nextXCenter = yAxis\n  nextYCenter = xAxis\n\n  ctx.clearRect(0, 0, width, height);\n\n  // Draw the axes in their own path\n  ctx.strokeStyle = axesStrokeColor;\n  ctx.beginPath();\n  drawAxes();\n\n  // Set styles for animated graphics\n  ctx.save();\n  ctx.strokeStyle = featureStrokeColor;\n  ctx.fillStyle = featureFillColor;\n  ctx.lineWidth = 1;\n\n\n\n  // Update the time and draw again\n  draw.t = (time - timeSubtract) / (100000 / speed);\n  runThroughConstituents(draw.t * Math.PI, drawEpicycles)\n  drawTideChart();\n  drawArrow();\n  drawBead()\n  ctx.restore();\n\n  setTimeout(draw, (1000 / frameRate));\n}\n\nconst runThroughConstituents = (time, drawFunction) => {\n  constituents.forEach((constituent, idx) => {\n    const radius = Math.floor(constituent.amplitude * unit)\n    drawFunction(radius)\n    getLocationOnCircle(time, radius, constituent)\n    if (idx == (constituents.length - 1)) {\n      timeSeriesChords = [...timeSeriesChords, nextYCenter].slice(-timeSeriesLength)\n    }\n  })\n}\n\nconst getRadians = (angle) => {\n  return (angle * (Math.PI / 180))\n}\n\nconst getLocationOnCircle = (time, radius, constituent) => {\n  let nextCenters = getPhasedXY(time, radius, constituent)\n  nextXCenter = nextCenters[0]\n  nextYCenter = nextCenters[1]\n}\n\nconst getPhasedXY = (time, radius, constituent) => {\n  const { phase_GMT, speed} = constituent\n  let phase = phase_GMT\n  let phaseX = nextXCenter + (radius * Math.sin(((time + getRadians(phase)) * speed)))\n  let phaseY = nextYCenter + (radius * Math.cos(((time + getRadians(phase)) * speed)))\n  return [phaseX, phaseY]\n}\n\nconst populateTimeSeries = (timeSeriesLength) => {\n  for (let i = 0; i < timeSeriesLength; i++) {\n    runThroughConstituents(i, emptyFunction)\n    timeSeriesChords.push(nextYCenter)\n  }\n}\n\n// Drawing functions\nconst drawArrow = () => {\n  ctx.beginPath()\n  ctx.setLineDash([5, 10]);\n  ctx.moveTo(yAxis, nextYCenter)\n  ctx.lineTo(nextXCenter, nextYCenter)\n  ctx.stroke()\n}\n\nconst drawBead = () => {\n  ctx.beginPath()\n      ctx.strokeStyle = beadColor;\n      ctx.fillStyle = beadColor;\n      ctx.arc(nextXCenter, nextYCenter, beadSize, 0, 2 * Math.PI, false);\n      ctx.fill();\n      ctx.stroke();\n      ctx.strokeStyle = featureStrokeColor; // restore color\n}\n\n\nconst drawEpicycles = (radius) => {\n  ctx.beginPath()\n  ctx.arc(nextXCenter, nextYCenter, radius, 0, 2 * Math.PI, false);\n  ctx.fill();\n  ctx.stroke();\n}\n\n\n\nfunction drawTideChart() {\n  ctx.beginPath();\n  ctx.moveTo(width, timeSeriesChords[0]);\n  timeSeriesChords.slice(1).forEach((yCoordinate, idx) => {\n    ctx.lineTo((width - ((idx + 1) * wavePrecision)), yCoordinate);\n  })\n  ctx.stroke();\n}\n\n\nconst drawAxes = () => {\n  // Draw X and Y axes\n  ctx.strokeStyle = axesStrokeColor;\n  ctx.moveTo(0, xAxis);\n  ctx.lineTo(width, xAxis);\n  ctx.moveTo(yAxis, 0);\n  ctx.lineTo(yAxis, height);\n  ctx.stroke();\n}\n\ninit()\n}\n\nexport default drawVisualizer\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}