{"ast":null,"code":"const drawVisualizer = function (harcon) {\n  let numOfConstituents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\n  let canvasSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [500, 500];\n  // Record the initial time so the delta can be calculated later\n  const timeSubtract = new Date().getTime(); // The amplitude indicators on the harmonics are called beads\n\n  const beadSize = 2;\n  const speed = 1;\n  const frameRate = 60;\n  const axesStrokeColor = 'rgba(128, 128, 128, 1)';\n  const featureFillColor = 'rgba(0, 128, 255, .1)';\n  const featureStrokeColor = 'rgba(0, 128, 255, 1)';\n  let beadColor = 'rgba(255, 0, 0, 1)';\n  const wavePrecision = .25; // How smooth the tide chart curves should be\n\n  let constituents = [...harcon];\n  constituents.sort((a, b) => b.amplitude - a.amplitude);\n  constituents = constituents.slice(0, numOfConstituents);\n  const scale = 1; // This is how much to scale by\n\n  const unit = constituents.reduce((a, b) => a.amplitude + b.amplitude, 0) * scale;\n  console.log(unit);\n  let timeSeriesChords = []; // declare a lot of variables that should not be redeclared each time\n\n  let canvas, ctx, height, width, xAxis, yAxis, x, y, nextXCenter, nextYCenter, timeSeriesLength;\n\n  const emptyFunction = () => {};\n\n  const init = () => {\n    // this may change, will revisit\n    canvas = document.getElementById(\"epicycleCanvas\");\n    canvas.width = canvasSize[0];\n    canvas.height = canvasSize[1];\n    ctx = canvas.getContext(\"2d\");\n    ctx.lineJoin = 'round';\n    height = canvas.height;\n    width = canvas.width;\n    xAxis = Math.floor(height / 2);\n    yAxis = Math.floor(width / 4);\n    timeSeriesLength = (width - yAxis) / wavePrecision;\n    populateTimeSeries(timeSeriesLength, emptyFunction);\n    ctx.save();\n    window.requestAnimationFrame(draw);\n  };\n\n  const draw = () => {\n    const time = new Date();\n    nextXCenter = yAxis;\n    nextYCenter = xAxis;\n    ctx.clearRect(0, 0, width, height); // Draw the axes in their own path\n\n    ctx.strokeStyle = axesStrokeColor;\n    ctx.beginPath();\n    drawAxes(); // Set styles for animated graphics\n\n    ctx.save();\n    ctx.strokeStyle = featureStrokeColor;\n    ctx.fillStyle = featureFillColor;\n    ctx.lineWidth = 1; // Update the time and draw again\n\n    draw.t = (time - timeSubtract) / (100000 / speed);\n    runThroughConstituents(draw.t * Math.PI, drawEpicycles);\n    drawTideChart();\n    drawArrow();\n    drawBead();\n    ctx.restore();\n    setTimeout(draw, 1000 / frameRate);\n  };\n\n  const runThroughConstituents = (time, drawFunction) => {\n    constituents.forEach((constituent, idx) => {\n      const radius = Math.floor(constituent.amplitude * unit);\n      drawFunction(radius);\n      getLocationOnCircle(time, radius, constituent);\n\n      if (idx == constituents.length - 1) {\n        timeSeriesChords = [...timeSeriesChords, nextYCenter].slice(-timeSeriesLength);\n      }\n    });\n  };\n\n  const getRadians = angle => {\n    return angle * (Math.PI / 180);\n  };\n\n  const getLocationOnCircle = (time, radius, constituent) => {\n    let nextCenters = getPhasedXY(time, radius, constituent);\n    nextXCenter = nextCenters[0];\n    nextYCenter = nextCenters[1];\n  };\n\n  const getPhasedXY = (time, radius, constituent) => {\n    const {\n      phase_GMT,\n      speed\n    } = constituent;\n    let phase = phase_GMT;\n    let phaseX = nextXCenter + radius * Math.sin((time + getRadians(phase)) * speed);\n    let phaseY = nextYCenter + radius * Math.cos((time + getRadians(phase)) * speed);\n    return [phaseX, phaseY];\n  };\n\n  const populateTimeSeries = timeSeriesLength => {\n    for (let i = 0; i < timeSeriesLength; i++) {\n      runThroughConstituents(i, emptyFunction);\n      timeSeriesChords.push(nextYCenter);\n    }\n  }; // Drawing functions\n\n\n  const drawArrow = () => {\n    ctx.beginPath();\n    ctx.setLineDash([5, 10]);\n    ctx.moveTo(yAxis, nextYCenter);\n    ctx.lineTo(nextXCenter, nextYCenter);\n    ctx.stroke();\n  };\n\n  const drawBead = () => {\n    ctx.beginPath();\n    ctx.strokeStyle = beadColor;\n    ctx.fillStyle = beadColor;\n    ctx.arc(nextXCenter, nextYCenter, beadSize, 0, 2 * Math.PI, false);\n    ctx.fill();\n    ctx.stroke();\n    ctx.strokeStyle = featureStrokeColor; // restore color\n  };\n\n  const drawEpicycles = radius => {\n    ctx.beginPath();\n    ctx.arc(nextXCenter, nextYCenter, radius, 0, 2 * Math.PI, false);\n    ctx.fill();\n    ctx.stroke();\n  };\n\n  function drawTideChart() {\n    ctx.beginPath();\n    ctx.moveTo(width, timeSeriesChords[0]);\n    timeSeriesChords.slice(1).forEach((yCoordinate, idx) => {\n      ctx.lineTo(width - (idx + 1) * wavePrecision, yCoordinate);\n    });\n    ctx.stroke();\n  }\n\n  const drawAxes = () => {\n    // Draw X and Y axes\n    ctx.strokeStyle = axesStrokeColor;\n    ctx.moveTo(0, xAxis);\n    ctx.lineTo(width, xAxis);\n    ctx.moveTo(yAxis, 0);\n    ctx.lineTo(yAxis, height);\n    ctx.stroke();\n  };\n\n  init();\n};\n\nexport default drawVisualizer;","map":{"version":3,"names":["drawVisualizer","harcon","numOfConstituents","canvasSize","timeSubtract","Date","getTime","beadSize","speed","frameRate","axesStrokeColor","featureFillColor","featureStrokeColor","beadColor","wavePrecision","constituents","sort","a","b","amplitude","slice","scale","unit","reduce","console","log","timeSeriesChords","canvas","ctx","height","width","xAxis","yAxis","x","y","nextXCenter","nextYCenter","timeSeriesLength","emptyFunction","init","document","getElementById","getContext","lineJoin","Math","floor","populateTimeSeries","save","window","requestAnimationFrame","draw","time","clearRect","strokeStyle","beginPath","drawAxes","fillStyle","lineWidth","t","runThroughConstituents","PI","drawEpicycles","drawTideChart","drawArrow","drawBead","restore","setTimeout","drawFunction","forEach","constituent","idx","radius","getLocationOnCircle","length","getRadians","angle","nextCenters","getPhasedXY","phase_GMT","phase","phaseX","sin","phaseY","cos","i","push","setLineDash","moveTo","lineTo","stroke","arc","fill","yCoordinate"],"sources":["/Users/donromaniello/Code/JavaScript/tidey/src/components/modules/drawHarmonicConstituents.js"],"sourcesContent":["\nconst drawVisualizer = (harcon, numOfConstituents = 5, canvasSize = [500, 500]) => {\n// Record the initial time so the delta can be calculated later\nconst timeSubtract = new Date().getTime()\n// The amplitude indicators on the harmonics are called beads\nconst beadSize = 2\nconst speed = 1\nconst frameRate = 60\nconst axesStrokeColor = 'rgba(128, 128, 128, 1)'\nconst featureFillColor = 'rgba(0, 128, 255, .1)'\nconst featureStrokeColor = 'rgba(0, 128, 255, 1)'\nlet beadColor = 'rgba(255, 0, 0, 1)'\nconst wavePrecision = .25 // How smooth the tide chart curves should be\nlet constituents = [...harcon]\nconstituents.sort((a, b) => b.amplitude - a.amplitude)\nconstituents = constituents.slice(0, numOfConstituents)\n\nconst scale = 1\n// This is how much to scale by\nconst unit = constituents.reduce((a, b) => a.amplitude + b.amplitude, 0) * scale\n\nconsole.log(unit)\n\nlet timeSeriesChords = []\n\n// declare a lot of variables that should not be redeclared each time\nlet canvas, ctx, height, width, xAxis, yAxis,\n    x, y, nextXCenter, nextYCenter, timeSeriesLength;\n\nconst emptyFunction = () => {\n}\n\nconst init = () => {\n  // this may change, will revisit\n  canvas = document.getElementById(\"epicycleCanvas\");\n\n  canvas.width = canvasSize[0];\n  canvas.height = canvasSize[1];\n\n  ctx = canvas.getContext(\"2d\");\n  ctx.lineJoin = 'round';\n\n  height = canvas.height;\n  width = canvas.width;\n\n  xAxis = Math.floor(height/2);\n  yAxis = Math.floor(width/4);\n\n  timeSeriesLength = ((width - yAxis) / wavePrecision)\n\n  populateTimeSeries(timeSeriesLength, emptyFunction)\n\n  ctx.save();\n\n  window.requestAnimationFrame(draw);\n}\n\nconst draw = () => {\n\n  const time = new Date()\n\n  nextXCenter = yAxis\n  nextYCenter = xAxis\n\n  ctx.clearRect(0, 0, width, height);\n\n  // Draw the axes in their own path\n  ctx.strokeStyle = axesStrokeColor;\n  ctx.beginPath();\n  drawAxes();\n\n  // Set styles for animated graphics\n  ctx.save();\n  ctx.strokeStyle = featureStrokeColor;\n  ctx.fillStyle = featureFillColor;\n  ctx.lineWidth = 1;\n\n\n\n  // Update the time and draw again\n  draw.t = (time - timeSubtract) / (100000 / speed);\n  runThroughConstituents(draw.t * Math.PI, drawEpicycles)\n  drawTideChart();\n  drawArrow();\n  drawBead()\n  ctx.restore();\n\n  setTimeout(draw, (1000 / frameRate));\n}\n\nconst runThroughConstituents = (time, drawFunction) => {\n  constituents.forEach((constituent, idx) => {\n    const radius = Math.floor(constituent.amplitude * unit)\n    drawFunction(radius)\n    getLocationOnCircle(time, radius, constituent)\n    if (idx == (constituents.length - 1)) {\n      timeSeriesChords = [...timeSeriesChords, nextYCenter].slice(-timeSeriesLength)\n    }\n  })\n}\n\nconst getRadians = (angle) => {\n  return (angle * (Math.PI / 180))\n}\n\nconst getLocationOnCircle = (time, radius, constituent) => {\n  let nextCenters = getPhasedXY(time, radius, constituent)\n  nextXCenter = nextCenters[0]\n  nextYCenter = nextCenters[1]\n}\n\nconst getPhasedXY = (time, radius, constituent) => {\n  const { phase_GMT, speed} = constituent\n  let phase = phase_GMT\n  let phaseX = nextXCenter + (radius * Math.sin(((time + getRadians(phase)) * speed)))\n  let phaseY = nextYCenter + (radius * Math.cos(((time + getRadians(phase)) * speed)))\n  return [phaseX, phaseY]\n}\n\nconst populateTimeSeries = (timeSeriesLength) => {\n  for (let i = 0; i < timeSeriesLength; i++) {\n    runThroughConstituents(i, emptyFunction)\n    timeSeriesChords.push(nextYCenter)\n  }\n}\n\n// Drawing functions\nconst drawArrow = () => {\n  ctx.beginPath()\n  ctx.setLineDash([5, 10]);\n  ctx.moveTo(yAxis, nextYCenter)\n  ctx.lineTo(nextXCenter, nextYCenter)\n  ctx.stroke()\n}\n\nconst drawBead = () => {\n  ctx.beginPath()\n      ctx.strokeStyle = beadColor;\n      ctx.fillStyle = beadColor;\n      ctx.arc(nextXCenter, nextYCenter, beadSize, 0, 2 * Math.PI, false);\n      ctx.fill();\n      ctx.stroke();\n      ctx.strokeStyle = featureStrokeColor; // restore color\n}\n\n\nconst drawEpicycles = (radius) => {\n  ctx.beginPath()\n  ctx.arc(nextXCenter, nextYCenter, radius, 0, 2 * Math.PI, false);\n  ctx.fill();\n  ctx.stroke();\n}\n\n\n\nfunction drawTideChart() {\n  ctx.beginPath();\n  ctx.moveTo(width, timeSeriesChords[0]);\n  timeSeriesChords.slice(1).forEach((yCoordinate, idx) => {\n    ctx.lineTo((width - ((idx + 1) * wavePrecision)), yCoordinate);\n  })\n  ctx.stroke();\n}\n\n\nconst drawAxes = () => {\n  // Draw X and Y axes\n  ctx.strokeStyle = axesStrokeColor;\n  ctx.moveTo(0, xAxis);\n  ctx.lineTo(width, xAxis);\n  ctx.moveTo(yAxis, 0);\n  ctx.lineTo(yAxis, height);\n  ctx.stroke();\n}\n\ninit()\n}\n\nexport default drawVisualizer\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}