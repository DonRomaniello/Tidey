{"ast":null,"code":"const drawVisualizer = function (harcon, canvasName, colorRange) {\n  let canvasSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [500, 500];\n  let loopCallback = arguments.length > 4 ? arguments[4] : undefined;\n  // Record the initial time so the delta can be calculated later\n  const timeSubtract = new Date().getTime(); // The amplitude indicators on the harmonics are called beads\n\n  let callbackMessages = loopCallback();\n  const beadSize = 2;\n  const mainSpeed = 1;\n  const frameRate = 60;\n  const axesStrokeColor = 'rgba(128, 128, 128, 1)';\n  const beadColor = 'rgba(255, 0, 0, 1)';\n  const wavePrecision = .25; // How smooth the tide chart curves should be\n\n  let constituents = [...harcon];\n  constituents.sort((a, b) => b.amplitude - a.amplitude);\n  constituents = constituents.slice(0, callbackMessages.numOfConstituents);\n  let width = canvasSize[0];\n  let height = canvasSize[1]; // This is how much to scale by\n\n  const scale = constituents.map(a => a.amplitude).reduce((a, b) => a + b);\n  const unit = height / 2 / scale;\n  let timeSeriesChords = []; // declare a lot of variables that should not be redeclared each time\n\n  let canvas, ctx, featureFillColor, featureStrokeColor, xAxis, yAxis, nextXCenter, nextYCenter, timeSeriesLength;\n\n  const emptyFunction = () => {};\n\n  const init = () => {\n    // this may change, will revisit\n    canvas = document.getElementById(canvasName);\n    canvas.width = canvasSize[0];\n    canvas.height = canvasSize[1];\n    ctx = canvas.getContext(\"2d\");\n    ctx.lineJoin = 'round';\n    xAxis = Math.floor(height / 2);\n    yAxis = Math.floor(width / 4 - scale);\n    timeSeriesLength = (width - yAxis) / wavePrecision;\n    populateTimeSeries(timeSeriesLength, emptyFunction);\n    ctx.save();\n    window.requestAnimationFrame(draw);\n  };\n\n  const draw = () => {\n    const time = new Date();\n    nextXCenter = yAxis;\n    nextYCenter = xAxis;\n    ctx.clearRect(0, 0, width, height); // Draw the axes in their own path\n\n    ctx.strokeStyle = axesStrokeColor;\n    ctx.beginPath();\n    drawAxes(); // Set styles for animated graphics\n\n    ctx.save();\n    ctx.strokeStyle = featureStrokeColor;\n    ctx.fillStyle = featureFillColor;\n    ctx.lineWidth = 1; // Update the time and draw again\n\n    draw.t = (time - timeSubtract) / (100000 / mainSpeed);\n    runThroughConstituents(draw.t * Math.PI, drawEpicycles);\n    drawTideChart();\n    drawArrow();\n    drawBead();\n    ctx.restore();\n    callbackMessages = loopCallback();\n\n    if (callbackMessages.continue) {\n      setTimeout(draw, 1000 / frameRate);\n    }\n  };\n\n  const runThroughConstituents = (time, drawFunction) => {\n    constituents.forEach((constituent, idx) => {\n      const radius = Math.floor(constituent.amplitude * unit);\n      drawFunction(radius, idx);\n      getLocationOnCircle(time, radius, constituent);\n\n      if (idx == constituents.length - 1) {\n        timeSeriesChords = [...timeSeriesChords, nextYCenter].slice(-timeSeriesLength);\n      }\n    });\n  };\n\n  const getRadians = angle => {\n    return angle * (Math.PI / 180);\n  };\n\n  const getSteppedColor = idx => {\n    let degreeB = idx / callbackMessages.numOfConstituents;\n    let degreeA = 1 - degreeB;\n    let r = colorRange.start.r * degreeA + colorRange.end.r * degreeB;\n    let g = colorRange.start.g * degreeA + colorRange.end.g * degreeB;\n    let b = colorRange.start.b * degreeA + colorRange.end.b * degreeB;\n    return {\n      r,\n      g,\n      b\n    };\n  };\n\n  const getLocationOnCircle = (time, radius, constituent) => {\n    let nextCenters = getPhasedXY(time, radius, constituent);\n    nextXCenter = nextCenters[0];\n    nextYCenter = nextCenters[1];\n  };\n\n  const getPhasedXY = (time, radius, constituent) => {\n    const {\n      phase_GMT,\n      speed\n    } = constituent;\n    let phase = phase_GMT;\n    let phaseX = nextXCenter + radius * Math.sin((time + getRadians(phase)) * speed);\n    let phaseY = nextYCenter + radius * Math.cos((time + getRadians(phase)) * speed);\n    return [phaseX, phaseY];\n  };\n\n  const populateTimeSeries = timeSeriesLength => {\n    for (let i = 0; i < timeSeriesLength; i++) {\n      runThroughConstituents(i, emptyFunction);\n      timeSeriesChords.push(nextYCenter);\n    }\n  }; // Drawing functions\n\n\n  const drawArrow = () => {\n    ctx.beginPath();\n    ctx.setLineDash([5, 10]);\n    ctx.moveTo(yAxis, nextYCenter);\n    ctx.lineTo(nextXCenter, nextYCenter);\n    ctx.stroke();\n  };\n\n  const drawBead = () => {\n    ctx.beginPath();\n    ctx.strokeStyle = beadColor;\n    ctx.fillStyle = beadColor;\n    ctx.arc(nextXCenter, nextYCenter, beadSize, 0, 2 * Math.PI, false);\n    ctx.fill();\n    ctx.stroke();\n    ctx.strokeStyle = featureStrokeColor; // restore color\n  };\n\n  const drawEpicycles = (radius, idx) => {\n    let baseColor = getSteppedColor(idx);\n    ctx.strokeStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 1)`;\n    ctx.fillStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, .2)`;\n    ctx.beginPath();\n    ctx.arc(nextXCenter, nextYCenter, radius, 0, 2 * Math.PI, false); // ctx.fill();\n\n    ctx.stroke();\n  };\n\n  function drawTideChart() {\n    ctx.beginPath();\n    ctx.moveTo(width, timeSeriesChords[0]);\n    timeSeriesChords.slice(1).forEach((yCoordinate, idx) => {\n      ctx.lineTo(width - (idx + 1) * wavePrecision, yCoordinate);\n    });\n    ctx.stroke();\n  }\n\n  const drawAxes = () => {\n    // Draw X and Y axes\n    ctx.strokeStyle = axesStrokeColor; // ctx.moveTo(0, xAxis);\n    // ctx.lineTo(width, xAxis);\n\n    ctx.moveTo(yAxis, 0);\n    ctx.lineTo(yAxis, height);\n    ctx.stroke();\n  };\n\n  init();\n};\n\nexport default drawVisualizer;","map":{"version":3,"names":["drawVisualizer","harcon","canvasName","colorRange","canvasSize","loopCallback","timeSubtract","Date","getTime","callbackMessages","beadSize","mainSpeed","frameRate","axesStrokeColor","beadColor","wavePrecision","constituents","sort","a","b","amplitude","slice","numOfConstituents","width","height","scale","map","reduce","unit","timeSeriesChords","canvas","ctx","featureFillColor","featureStrokeColor","xAxis","yAxis","nextXCenter","nextYCenter","timeSeriesLength","emptyFunction","init","document","getElementById","getContext","lineJoin","Math","floor","populateTimeSeries","save","window","requestAnimationFrame","draw","time","clearRect","strokeStyle","beginPath","drawAxes","fillStyle","lineWidth","t","runThroughConstituents","PI","drawEpicycles","drawTideChart","drawArrow","drawBead","restore","continue","setTimeout","drawFunction","forEach","constituent","idx","radius","getLocationOnCircle","length","getRadians","angle","getSteppedColor","degreeB","degreeA","r","start","end","g","nextCenters","getPhasedXY","phase_GMT","speed","phase","phaseX","sin","phaseY","cos","i","push","setLineDash","moveTo","lineTo","stroke","arc","fill","baseColor","yCoordinate"],"sources":["/Users/donromaniello/Code/JavaScript/tidey/src/components/modules/drawHarmonicConstituents.js"],"sourcesContent":["\nconst drawVisualizer = (harcon,\n  canvasName,\n  colorRange,\n    canvasSize = [500, 500],\n    loopCallback) => {\n// Record the initial time so the delta can be calculated later\nconst timeSubtract = new Date().getTime()\n// The amplitude indicators on the harmonics are called beads\nlet callbackMessages = loopCallback()\nconst beadSize = 2\nconst mainSpeed = 1\nconst frameRate = 60\nconst axesStrokeColor = 'rgba(128, 128, 128, 1)'\nconst beadColor = 'rgba(255, 0, 0, 1)'\nconst wavePrecision = .25 // How smooth the tide chart curves should be\nlet constituents = [...harcon]\nconstituents.sort((a, b) => b.amplitude - a.amplitude)\nconstituents = constituents.slice(0, callbackMessages.numOfConstituents)\nlet width = canvasSize[0]\nlet height = canvasSize[1]\n// This is how much to scale by\nconst scale = constituents.map((a) => a.amplitude).reduce((a, b) => a + b)\n\nconst unit = ((height / 2) / scale)\n\nlet timeSeriesChords = []\n\n// declare a lot of variables that should not be redeclared each time\nlet canvas, ctx, featureFillColor, featureStrokeColor, xAxis, yAxis,\n   nextXCenter, nextYCenter, timeSeriesLength;\n\nconst emptyFunction = () => {\n}\n\nconst init = () => {\n  // this may change, will revisit\n  canvas = document.getElementById(canvasName);\n\n  canvas.width = canvasSize[0];\n  canvas.height = canvasSize[1];\n\n  ctx = canvas.getContext(\"2d\");\n  ctx.lineJoin = 'round';\n\n  xAxis = Math.floor(height/2);\n  yAxis = Math.floor(width/4 - scale);\n\n  timeSeriesLength = ((width - yAxis) / wavePrecision)\n\n  populateTimeSeries(timeSeriesLength, emptyFunction)\n\n  ctx.save();\n\n  window.requestAnimationFrame(draw);\n}\n\nconst draw = () => {\n\n  const time = new Date()\n\n  nextXCenter = yAxis\n  nextYCenter = xAxis\n\n  ctx.clearRect(0, 0, width, height);\n\n  // Draw the axes in their own path\n  ctx.strokeStyle = axesStrokeColor;\n  ctx.beginPath();\n  drawAxes();\n\n  // Set styles for animated graphics\n  ctx.save();\n  ctx.strokeStyle = featureStrokeColor;\n  ctx.fillStyle = featureFillColor;\n  ctx.lineWidth = 1;\n\n  // Update the time and draw again\n  draw.t = (time - timeSubtract) / (100000 / mainSpeed);\n  runThroughConstituents(draw.t * Math.PI, drawEpicycles)\n  drawTideChart();\n  drawArrow();\n  drawBead()\n  ctx.restore();\n\n  callbackMessages = loopCallback()\n\n  if (callbackMessages.continue){\n    setTimeout(draw, (1000 / frameRate));\n  }\n\n}\n\nconst runThroughConstituents = (time, drawFunction) => {\n  constituents.forEach((constituent, idx) => {\n    const radius = Math.floor(constituent.amplitude * unit)\n    drawFunction(radius, idx)\n    getLocationOnCircle(time, radius, constituent)\n    if (idx == (constituents.length - 1)) {\n      timeSeriesChords = [...timeSeriesChords, nextYCenter].slice(-timeSeriesLength)\n    }\n  })\n}\n\nconst getRadians = (angle) => {\n  return (angle * (Math.PI / 180))\n}\n\nconst getSteppedColor = (idx) => {\n  let degreeB = idx / callbackMessages.numOfConstituents\n  let degreeA = 1 - degreeB\n  let r = (colorRange.start.r * degreeA) + (colorRange.end.r * degreeB)\n  let g = (colorRange.start.g * degreeA) + (colorRange.end.g * degreeB)\n  let b = (colorRange.start.b * degreeA) + (colorRange.end.b * degreeB)\n  return { r, g, b}\n}\n\n\nconst getLocationOnCircle = (time, radius, constituent) => {\n  let nextCenters = getPhasedXY(time, radius, constituent)\n  nextXCenter = nextCenters[0]\n  nextYCenter = nextCenters[1]\n}\n\nconst getPhasedXY = (time, radius, constituent) => {\n  const { phase_GMT, speed} = constituent\n  let phase = phase_GMT\n  let phaseX = nextXCenter + (radius * Math.sin(((time + getRadians(phase)) * speed)))\n  let phaseY = nextYCenter + (radius * Math.cos(((time + getRadians(phase)) * speed)))\n  return [phaseX, phaseY]\n}\n\nconst populateTimeSeries = (timeSeriesLength) => {\n  for (let i = 0; i < timeSeriesLength; i++) {\n    runThroughConstituents(i, emptyFunction)\n    timeSeriesChords.push(nextYCenter)\n  }\n}\n\n// Drawing functions\nconst drawArrow = () => {\n  ctx.beginPath()\n  ctx.setLineDash([5, 10]);\n  ctx.moveTo(yAxis, nextYCenter)\n  ctx.lineTo(nextXCenter, nextYCenter)\n  ctx.stroke()\n}\n\nconst drawBead = () => {\n  ctx.beginPath()\n      ctx.strokeStyle = beadColor;\n      ctx.fillStyle = beadColor;\n      ctx.arc(nextXCenter, nextYCenter, beadSize, 0, 2 * Math.PI, false);\n      ctx.fill();\n      ctx.stroke();\n      ctx.strokeStyle = featureStrokeColor; // restore color\n}\n\n\nconst drawEpicycles = (radius, idx) => {\n  let baseColor = getSteppedColor(idx)\n  ctx.strokeStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, 1)`\n  ctx.fillStyle = `rgba(${baseColor.r}, ${baseColor.g}, ${baseColor.b}, .2)`\n  ctx.beginPath()\n  ctx.arc(nextXCenter, nextYCenter, radius, 0, 2 * Math.PI, false);\n  // ctx.fill();\n  ctx.stroke();\n}\n\nfunction drawTideChart() {\n  ctx.beginPath();\n  ctx.moveTo(width, timeSeriesChords[0]);\n  timeSeriesChords.slice(1).forEach((yCoordinate, idx) => {\n    ctx.lineTo((width - ((idx + 1) * wavePrecision)), yCoordinate);\n  })\n  ctx.stroke();\n}\n\n\nconst drawAxes = () => {\n  // Draw X and Y axes\n  ctx.strokeStyle = axesStrokeColor;\n  // ctx.moveTo(0, xAxis);\n  // ctx.lineTo(width, xAxis);\n  ctx.moveTo(yAxis, 0);\n  ctx.lineTo(yAxis, height);\n  ctx.stroke();\n}\n\ninit()\n\n}\n\n\n\nexport default drawVisualizer\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}