{"ast":null,"code":"const drawVisualizer = function (harcon, canvasName, colorRange) {\n  let canvasSize = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [500, 500];\n  let loopCallback = arguments.length > 4 ? arguments[4] : undefined;\n  // Record the initial time so the delta can be calculated later\n  const timeSubtract = new Date().getTime(); // The amplitude indicators on the harmonics are called beads\n\n  let callbackMessages = loopCallback();\n  const beadSize = 2;\n  const mainSpeed = 1;\n  const frameRate = 60;\n  const axesStrokeColor = 'rgba(128, 128, 128, 1)';\n  const beadColor = 'rgba(255, 0, 0, 1)';\n  const wavePrecision = .25; // How smooth the tide chart curves should be\n\n  const colorSums = {\n    r: colorRange.start.r + colorRange.end.r,\n    g: colorRange.start.g + colorRange.end.g,\n    b: colorRange.start.b + colorRange.end.b\n  };\n  let constituents = [...harcon];\n  constituents.sort((a, b) => b.amplitude - a.amplitude);\n  constituents = constituents.slice(0, callbackMessages.numOfConstituents);\n  let width = canvasSize[0];\n  let height = canvasSize[1]; // This is how much to scale by\n\n  const scale = constituents.map(a => a.amplitude).reduce((a, b) => a + b);\n  const unit = height / 2 / scale;\n  let timeSeriesChords = []; // declare a lot of variables that should not be redeclared each time\n\n  let canvas, ctx, featureFillColor, featureStrokeColor, xAxis, yAxis, nextXCenter, nextYCenter, timeSeriesLength;\n\n  const emptyFunction = () => {};\n\n  const init = () => {\n    // this may change, will revisit\n    canvas = document.getElementById(canvasName);\n    canvas.width = canvasSize[0];\n    canvas.height = canvasSize[1];\n    ctx = canvas.getContext(\"2d\");\n    ctx.lineJoin = 'round';\n    xAxis = Math.floor(height / 2);\n    yAxis = Math.floor(width / 4 - scale);\n    timeSeriesLength = (width - yAxis) / wavePrecision;\n    populateTimeSeries(timeSeriesLength, emptyFunction);\n    ctx.save();\n    window.requestAnimationFrame(draw);\n  };\n\n  const draw = () => {\n    const time = new Date();\n    nextXCenter = yAxis;\n    nextYCenter = xAxis;\n    ctx.clearRect(0, 0, width, height); // Draw the axes in their own path\n\n    ctx.strokeStyle = axesStrokeColor;\n    ctx.beginPath();\n    drawAxes(); // Set styles for animated graphics\n\n    ctx.save();\n    ctx.strokeStyle = featureStrokeColor;\n    ctx.fillStyle = featureFillColor;\n    ctx.lineWidth = 1; // Update the time and draw again\n\n    draw.t = (time - timeSubtract) / (100000 / mainSpeed);\n    runThroughConstituents(draw.t * Math.PI, drawEpicycles);\n    drawTideChart();\n    drawArrow();\n    drawBead();\n    ctx.restore();\n    callbackMessages = loopCallback();\n\n    if (callbackMessages.continue) {\n      setTimeout(draw, 1000 / frameRate);\n    }\n  };\n\n  const runThroughConstituents = (time, drawFunction) => {\n    constituents.forEach((constituent, idx) => {\n      const radius = Math.floor(constituent.amplitude * unit);\n      drawFunction(radius);\n      getLocationOnCircle(time, radius, constituent);\n\n      if (idx == constituents.length - 1) {\n        timeSeriesChords = [...timeSeriesChords, nextYCenter].slice(-timeSeriesLength);\n      }\n    });\n  };\n\n  const getRadians = angle => {\n    return angle * (Math.PI / 180);\n  };\n\n  const getColorForConstituent = idx => {};\n\n  const getLocationOnCircle = (time, radius, constituent) => {\n    let nextCenters = getPhasedXY(time, radius, constituent);\n    nextXCenter = nextCenters[0];\n    nextYCenter = nextCenters[1];\n  };\n\n  const getPhasedXY = (time, radius, constituent) => {\n    const {\n      phase_GMT,\n      speed\n    } = constituent;\n    let phase = phase_GMT;\n    let phaseX = nextXCenter + radius * Math.sin((time + getRadians(phase)) * speed);\n    let phaseY = nextYCenter + radius * Math.cos((time + getRadians(phase)) * speed);\n    return [phaseX, phaseY];\n  };\n\n  const populateTimeSeries = timeSeriesLength => {\n    for (let i = 0; i < timeSeriesLength; i++) {\n      runThroughConstituents(i, emptyFunction);\n      timeSeriesChords.push(nextYCenter);\n    }\n  }; // Drawing functions\n\n\n  const drawArrow = () => {\n    ctx.beginPath();\n    ctx.setLineDash([5, 10]);\n    ctx.moveTo(yAxis, nextYCenter);\n    ctx.lineTo(nextXCenter, nextYCenter);\n    ctx.stroke();\n  };\n\n  const drawBead = () => {\n    ctx.beginPath();\n    ctx.strokeStyle = beadColor;\n    ctx.fillStyle = beadColor;\n    ctx.arc(nextXCenter, nextYCenter, beadSize, 0, 2 * Math.PI, false);\n    ctx.fill();\n    ctx.stroke();\n    ctx.strokeStyle = featureStrokeColor; // restore color\n  };\n\n  const drawEpicycles = radius => {\n    ctx.beginPath();\n    ctx.arc(nextXCenter, nextYCenter, radius, 0, 2 * Math.PI, false);\n    ctx.fill();\n    ctx.stroke();\n  };\n\n  function drawTideChart() {\n    ctx.beginPath();\n    ctx.moveTo(width, timeSeriesChords[0]);\n    timeSeriesChords.slice(1).forEach((yCoordinate, idx) => {\n      ctx.lineTo(width - (idx + 1) * wavePrecision, yCoordinate);\n    });\n    ctx.stroke();\n  }\n\n  const drawAxes = () => {\n    // Draw X and Y axes\n    ctx.strokeStyle = axesStrokeColor;\n    ctx.moveTo(0, xAxis);\n    ctx.lineTo(width, xAxis);\n    ctx.moveTo(yAxis, 0);\n    ctx.lineTo(yAxis, height);\n    ctx.stroke();\n  };\n\n  init();\n};\n\nexport default drawVisualizer;","map":{"version":3,"names":["drawVisualizer","harcon","canvasName","colorRange","canvasSize","loopCallback","timeSubtract","Date","getTime","callbackMessages","beadSize","mainSpeed","frameRate","axesStrokeColor","beadColor","wavePrecision","colorSums","r","start","end","g","b","constituents","sort","a","amplitude","slice","numOfConstituents","width","height","scale","map","reduce","unit","timeSeriesChords","canvas","ctx","featureFillColor","featureStrokeColor","xAxis","yAxis","nextXCenter","nextYCenter","timeSeriesLength","emptyFunction","init","document","getElementById","getContext","lineJoin","Math","floor","populateTimeSeries","save","window","requestAnimationFrame","draw","time","clearRect","strokeStyle","beginPath","drawAxes","fillStyle","lineWidth","t","runThroughConstituents","PI","drawEpicycles","drawTideChart","drawArrow","drawBead","restore","continue","setTimeout","drawFunction","forEach","constituent","idx","radius","getLocationOnCircle","length","getRadians","angle","getColorForConstituent","nextCenters","getPhasedXY","phase_GMT","speed","phase","phaseX","sin","phaseY","cos","i","push","setLineDash","moveTo","lineTo","stroke","arc","fill","yCoordinate"],"sources":["/Users/donromaniello/Code/JavaScript/tidey/src/components/modules/drawHarmonicConstituents.js"],"sourcesContent":["\nconst drawVisualizer = (harcon,\n  canvasName,\n  colorRange,\n    canvasSize = [500, 500],\n    loopCallback) => {\n// Record the initial time so the delta can be calculated later\nconst timeSubtract = new Date().getTime()\n// The amplitude indicators on the harmonics are called beads\nlet callbackMessages = loopCallback()\nconst beadSize = 2\nconst mainSpeed = 1\nconst frameRate = 60\nconst axesStrokeColor = 'rgba(128, 128, 128, 1)'\nconst beadColor = 'rgba(255, 0, 0, 1)'\nconst wavePrecision = .25 // How smooth the tide chart curves should be\nconst colorSums = {\n  r: colorRange.start.r + colorRange.end.r,\n  g: colorRange.start.g + colorRange.end.g,\n  b: colorRange.start.b + colorRange.end.b,\n}\n\n\nlet constituents = [...harcon]\nconstituents.sort((a, b) => b.amplitude - a.amplitude)\nconstituents = constituents.slice(0, callbackMessages.numOfConstituents)\nlet width = canvasSize[0]\nlet height = canvasSize[1]\n// This is how much to scale by\nconst scale = constituents.map((a) => a.amplitude).reduce((a, b) => a + b)\n\nconst unit = ((height / 2) / scale)\n\nlet timeSeriesChords = []\n\n// declare a lot of variables that should not be redeclared each time\nlet canvas, ctx, featureFillColor, featureStrokeColor, xAxis, yAxis,\n   nextXCenter, nextYCenter, timeSeriesLength;\n\nconst emptyFunction = () => {\n}\n\nconst init = () => {\n  // this may change, will revisit\n  canvas = document.getElementById(canvasName);\n\n  canvas.width = canvasSize[0];\n  canvas.height = canvasSize[1];\n\n  ctx = canvas.getContext(\"2d\");\n  ctx.lineJoin = 'round';\n\n  xAxis = Math.floor(height/2);\n  yAxis = Math.floor(width/4 - scale);\n\n  timeSeriesLength = ((width - yAxis) / wavePrecision)\n\n  populateTimeSeries(timeSeriesLength, emptyFunction)\n\n  ctx.save();\n\n  window.requestAnimationFrame(draw);\n}\n\nconst draw = () => {\n\n  const time = new Date()\n\n  nextXCenter = yAxis\n  nextYCenter = xAxis\n\n  ctx.clearRect(0, 0, width, height);\n\n  // Draw the axes in their own path\n  ctx.strokeStyle = axesStrokeColor;\n  ctx.beginPath();\n  drawAxes();\n\n  // Set styles for animated graphics\n  ctx.save();\n  ctx.strokeStyle = featureStrokeColor;\n  ctx.fillStyle = featureFillColor;\n  ctx.lineWidth = 1;\n\n\n\n  // Update the time and draw again\n  draw.t = (time - timeSubtract) / (100000 / mainSpeed);\n  runThroughConstituents(draw.t * Math.PI, drawEpicycles)\n  drawTideChart();\n  drawArrow();\n  drawBead()\n  ctx.restore();\n\n  callbackMessages = loopCallback()\n\n  if (callbackMessages.continue){\n    setTimeout(draw, (1000 / frameRate));\n  }\n\n}\n\nconst runThroughConstituents = (time, drawFunction) => {\n  constituents.forEach((constituent, idx) => {\n    const radius = Math.floor(constituent.amplitude * unit)\n    drawFunction(radius)\n    getLocationOnCircle(time, radius, constituent)\n    if (idx == (constituents.length - 1)) {\n      timeSeriesChords = [...timeSeriesChords, nextYCenter].slice(-timeSeriesLength)\n    }\n  })\n}\n\nconst getRadians = (angle) => {\n  return (angle * (Math.PI / 180))\n}\n\nconst getColorForConstituent = (idx) => {\n\n\n\n\n\n\n}\n\n\nconst getLocationOnCircle = (time, radius, constituent) => {\n  let nextCenters = getPhasedXY(time, radius, constituent)\n  nextXCenter = nextCenters[0]\n  nextYCenter = nextCenters[1]\n}\n\nconst getPhasedXY = (time, radius, constituent) => {\n  const { phase_GMT, speed} = constituent\n  let phase = phase_GMT\n  let phaseX = nextXCenter + (radius * Math.sin(((time + getRadians(phase)) * speed)))\n  let phaseY = nextYCenter + (radius * Math.cos(((time + getRadians(phase)) * speed)))\n  return [phaseX, phaseY]\n}\n\nconst populateTimeSeries = (timeSeriesLength) => {\n  for (let i = 0; i < timeSeriesLength; i++) {\n    runThroughConstituents(i, emptyFunction)\n    timeSeriesChords.push(nextYCenter)\n  }\n}\n\n// Drawing functions\nconst drawArrow = () => {\n  ctx.beginPath()\n  ctx.setLineDash([5, 10]);\n  ctx.moveTo(yAxis, nextYCenter)\n  ctx.lineTo(nextXCenter, nextYCenter)\n  ctx.stroke()\n}\n\nconst drawBead = () => {\n  ctx.beginPath()\n      ctx.strokeStyle = beadColor;\n      ctx.fillStyle = beadColor;\n      ctx.arc(nextXCenter, nextYCenter, beadSize, 0, 2 * Math.PI, false);\n      ctx.fill();\n      ctx.stroke();\n      ctx.strokeStyle = featureStrokeColor; // restore color\n}\n\n\nconst drawEpicycles = (radius) => {\n  ctx.beginPath()\n  ctx.arc(nextXCenter, nextYCenter, radius, 0, 2 * Math.PI, false);\n  ctx.fill();\n  ctx.stroke();\n}\n\nfunction drawTideChart() {\n  ctx.beginPath();\n  ctx.moveTo(width, timeSeriesChords[0]);\n  timeSeriesChords.slice(1).forEach((yCoordinate, idx) => {\n    ctx.lineTo((width - ((idx + 1) * wavePrecision)), yCoordinate);\n  })\n  ctx.stroke();\n}\n\n\nconst drawAxes = () => {\n  // Draw X and Y axes\n  ctx.strokeStyle = axesStrokeColor;\n  ctx.moveTo(0, xAxis);\n  ctx.lineTo(width, xAxis);\n  ctx.moveTo(yAxis, 0);\n  ctx.lineTo(yAxis, height);\n  ctx.stroke();\n}\n\ninit()\n\n}\n\n\n\nexport default drawVisualizer\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}